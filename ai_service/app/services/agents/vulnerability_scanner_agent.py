"""
Vulnerability Scanner Agent

This agent finds individual security vulnerabilities in an OpenAPI specification.
It wraps the existing multi-analyzer security workflow and converts findings
into a format suitable for attack path analysis.
"""

import logging
from datetime import datetime
from typing import Any, Dict, List

from ...schemas.attack_path_schemas import AttackPathContext
from ...schemas.security_schemas import SecurityIssue, SecuritySeverity
from ..security.security_workflow import SecurityAnalysisWorkflow
from .base_agent import BaseAgent

logger = logging.getLogger(__name__)


class VulnerabilityScannerAgent(BaseAgent):
    """
    Scanner Agent - Finds individual vulnerabilities using deterministic analysis

    This agent acts as the "Linter" in the attack path workflow. It discovers
    all individual security issues without considering how they might be chained.
    """

    def __init__(self):
        super().__init__(
            name="VulnerabilityScanner",
            description="Finds individual security vulnerabilities in OpenAPI specs",
        )
        self.security_workflow = SecurityAnalysisWorkflow()

    def _define_capabilities(self) -> List[str]:
        """Define the capabilities of this agent"""
        return [
            "authentication_analysis",
            "authorization_analysis",
            "data_exposure_detection",
            "owasp_compliance_checking",
            "security_misconfiguration_detection",
        ]

    async def execute(
        self, task: Dict[str, Any], context: AttackPathContext
    ) -> Dict[str, Any]:
        """
        Execute vulnerability scanning on the OpenAPI spec

        Args:
            task: Task parameters (currently unused, uses context.spec)
            context: Attack path MCP context containing the spec

        Returns:
            Dict with:
                - vulnerabilities_found: List[SecurityIssue]
                - scan_statistics: Dict with counts and metadata
        """
        logger.info(f"[{self.name}] Starting vulnerability scan...")
        start_time = datetime.utcnow()

        try:
            # Update context status
            context.current_stage = "scanning"
            context.current_activity = "Running security analyzers..."
            context.progress_percentage = 10.0

            # Run the comprehensive security analysis
            # Convert spec dict back to JSON string for the analyzer
            import json

            spec_text = json.dumps(context.spec)

            logger.info(
                f"[{self.name}] Analyzing spec with {len(context.spec.get('paths', {}))} endpoints"
            )
            security_report = await self.security_workflow.analyze(spec_text)

            # Extract all issues from the report
            all_issues: List[SecurityIssue] = security_report.all_issues

            logger.info(f"[{self.name}] Found {len(all_issues)} security issues")

            # Categorize by severity
            critical = [
                i for i in all_issues if i.severity == SecuritySeverity.CRITICAL
            ]
            high = [i for i in all_issues if i.severity == SecuritySeverity.HIGH]
            medium = [i for i in all_issues if i.severity == SecuritySeverity.MEDIUM]
            low = [i for i in all_issues if i.severity == SecuritySeverity.LOW]
            info = [i for i in all_issues if i.severity == SecuritySeverity.INFO]

            # Store in context
            context.individual_vulnerabilities = all_issues
            context.stages_completed.append("scanning")
            context.progress_percentage = 30.0

            # Calculate execution time
            execution_time = (datetime.utcnow() - start_time).total_seconds() * 1000
            context.total_execution_time_ms += execution_time

            # Prepare statistics
            scan_statistics = {
                "total_vulnerabilities": len(all_issues),
                "by_severity": {
                    "critical": len(critical),
                    "high": len(high),
                    "medium": len(medium),
                    "low": len(low),
                    "info": len(info),
                },
                "by_owasp_category": self._group_by_owasp(all_issues),
                "endpoints_analyzed": len(context.spec.get("paths", {})),
                "execution_time_ms": execution_time,
            }

            logger.info(
                f"[{self.name}] Scan complete: "
                f"{len(critical)} critical, {len(high)} high, "
                f"{len(medium)} medium, {len(low)} low"
            )

            return {
                "success": True,
                "vulnerabilities_found": all_issues,
                "scan_statistics": scan_statistics,
            }

        except Exception as e:
            logger.error(
                f"[{self.name}] Error during vulnerability scan: {e}", exc_info=True
            )
            context.current_stage = "error"
            return {"success": False, "error": str(e), "vulnerabilities_found": []}

    def can_handle_task(self, task_type: str) -> bool:
        """Check if this agent can handle the given task type"""
        return task_type in [
            "vulnerability_scan",
            "security_analysis",
            "find_vulnerabilities",
        ]

    def _group_by_owasp(self, issues: List[SecurityIssue]) -> Dict[str, int]:
        """Group vulnerabilities by OWASP API category"""
        owasp_counts = {}
        for issue in issues:
            category = (
                issue.owasp_category.value if issue.owasp_category else "uncategorized"
            )
            owasp_counts[category] = owasp_counts.get(category, 0) + 1
        return owasp_counts
